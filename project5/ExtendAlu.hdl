/**
* The input of the extends ALU is instruction[9] and x[16],y[16].
* the output is define as follows:
* If instruction[7..8] equals 1 the the output is exactly as the ALU.
* Where instruction[5]=zx,instruction[4]=nx,...,instruction[0]=no.
* If instruction[7] equals 0 the output will be x*y and disregard the rest 
* of the instruction.
*
* If instruction[8] equals 0 the output will be shift.
* Then, if instruction[4] equals 0 it will return shift of y otherwise shift 
* of x, moreover if instruction[5] equals 0 it will return shift right 
* otherwise shift left.
**/


CHIP ExtendAlu{
     IN x[16],y[16],instruction[9];
     OUT out[16],zr,ng;
     
    PARTS:
    // if instruction[7] == 1 and instruction[8]== 1, outputs as regular ALU:
    And(a=instruction[7], b=instruction[8], out=exactAlu);

    // in case of ALU:
    ALU(x=x, y=y, zx=instruction[5], nx=instruction[4], zy=instruction[3], ny=instruction[2],
    f=instruction[1], no=instruction[0], out=aluOut, zr=aluZr, ng=aluNg);

    // in case of mult:
    Mul(a=x, b=y, out=mulOut);

    // in case if shift:
    Not(in=instruction[8], out=toShift);
    Mux16(a=y, b=x, sel=instruction[4], out=xOry);
    ShiftLeft(in=xOry, out=shiftedLeft);
    ShiftRight(in=xOry, out=shiftedRight);
    Mux16(a=shiftedRight, b=shiftedLeft, sel=instruction[5], out=shiftedOut);

    // choosing the right instruction:
    Mux4Way16(a=mulOut, b=shiftedOut, c=mulOut, d=aluOut,
     sel=instruction[7..8], out[15]=ng, out=out1, out=out);

    // outputs the ng, zr:
    Or16Way(in=out1, out=isZero);
    Mux(a=true, b=false, sel=isZero, out=zr);
}	